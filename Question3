import threading  # Importing threading library for multithreading
import time  # Importing time library to measure time in nanoseconds
import random  # Importing random library to generate random numbers

# Function to generate 100 random numbers between 0 and 10000
def generate_random_numbers():
    return [random.randint(0, 10000) for _ in range(100)]  # List of random numbers

# Function to generate and process a set of random numbers (one of the three sets)
def generate_and_process_set(set_number, mode=""):
    start_time = time.time_ns()  # Record the start time in nanoseconds using time.time_ns()
    random_numbers = generate_random_numbers()  # Generate random numbers using the previously defined function
    end_time = time.time_ns()  # Record the end time in nanoseconds

    time_taken = end_time - start_time  # Calculate the time taken for this operation by subtracting start from end time
    print(f"Set {set_number} ({mode}) took {time_taken} ns")  # Label time with the mode (Multithreading or Non-Multithreading)
    return time_taken  # Return the time taken for this specific set of numbers

# Function to run all 3 sets using multithreading
def run_multithreading():
    threads = []  # List to keep track of the threads
    times = []  # List to store the time taken for each thread (set)

    # Create 3 separate threads to handle 3 sets of random number generation
    for i in range(1, 4):  # Loop to create 3 threads (one for each set)
        thread = threading.Thread(target=lambda i=i: times.append(generate_and_process_set(i, "Multithreading")))  # Create a thread
        threads.append(thread)  # Add thread to the list of threads
        thread.start()  # Start the thread, invoking the target function

    # Wait for all threads to finish before proceeding
    for thread in threads:
        thread.join()  # Ensure that the main program waits until all threads are done

    return times  # Return the times for each set

# Function to run the sets without multithreading (sequentially)
def run_without_multithreading():
    times = []  # List to store time taken for each set

    # Sequentially run each set and store the time taken
    for i in range(1, 4):  # Loop to process 3 sets
        times.append(generate_and_process_set(i, "Non-Multithreading"))  # Add the time taken for the set to the list

    return times  # Return the times for each set

# Function to run the experiment for 10 rounds
def experiment():
    # Initialize variables to store cumulative times for multithreading and non-multithreading
    multithreading_total_time = 0
    multithreading_avg_time = 0
    non_multithreading_total_time = 0
    non_multithreading_avg_time = 0

    # Run the experiment for 10 rounds to compare multithreading vs non-multithreading performance
    for round_num in range(10):  # Loop through 10 rounds
        print(f"\nRound {round_num + 1}:")

        # Measure multithreading performance (run once per round)
        print("  Multithreading Results:")
        multithreading_times = run_multithreading()

        # Measure non-multithreading performance (run once per round)
        print("  Non-Multithreading Results:")
        non_multithreading_times = run_without_multithreading()

        # Calculate and accumulate the total time for multithreading
        multithreading_total_time += sum(multithreading_times)
        # Calculate and accumulate the total time for non-multithreading
        non_multithreading_total_time += sum(non_multithreading_times)

        # Calculate the average time for multithreading
        multithreading_avg_time += sum(multithreading_times) / len(multithreading_times)
        # Calculate the average time for non-multithreading
        non_multithreading_avg_time += sum(non_multithreading_times) / len(non_multithreading_times)

    # After 10 rounds, calculate the final total and average times for both methods
    print("\nSummary of Results:")
    print(f"Multithreading Total Time: {multithreading_total_time} ns")
    print(f"Non-Multithreading Total Time: {non_multithreading_total_time} ns")
    print(f"Multithreading Average Time: {multithreading_avg_time / 10} ns")
    print(f"Non-Multithreading Average Time: {non_multithreading_avg_time / 10} ns")
    print("=== Code Execution Successful ===")

# Run the experiment
experiment()  # Call the function to run the experiment and display the results
